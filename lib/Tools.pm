# -*- mode: cperl -*-
#

package Tools;
use Moose::Role;


=head2 is_ascii

checks whether the argument is ASCII

returns 0 if it is and 1 if not

=cut


sub is_ascii {
  my ($self, $arg) = @_;
  if ( defined $arg && $arg ne '' &&
       $arg !~ /^[[:ascii:]]+$/ ) {
    return 1;
  } else {
    return 0;
  }
}

=head2 utf2lat

utf8 input (particularly cyrillic) to latin1 transliteration

=cut

sub utf2lat {
  my ($self, $to_translit) = @_;

  use utf8;
  use Text::Unidecode;

  utf8::decode( $to_translit );

  return unidecode( $to_translit );
}

sub is_int {
  my ($self, $arg) = @_;
  return $arg !~ /^\d+$/ ? 1 : 0;
}


=head2 pwdgen

Prepares with Digest::SHA1, password provided or autogenerated, to be
used as userPassword attribute value

Password generated (with Crypt::GeneratePassword) is a random
pronounceable word. The length of the returned word is 12 chars. It is
up to 3 numbers and special characters will occur in the password. It
is up to 4 characters will be upper case.

If no password provided, then it will be automatically generated.

Method returns hash with cleartext and ssha coded password.

=cut


sub pwdgen {
  my ( $self, $args ) = @_;
  my $pwdgen = {
		pwd => $args->{'pwd'},
		len => $args->{'len'} || 12,
		num => $args->{'num'} || 3,
		cap => $args->{'cap'} || 4,
		cnt => $args->{'cnt'} || 1,
		salt => $args->{'salt'} || '123456789',
		pronounceable => $args->{'pronounceable'} || 1,
	       };

  use Crypt::GeneratePassword qw(word word3 chars);

  if ( ! defined $pwdgen->{'pwd'} && defined $pwdgen->{'pronounceable'} ) {
    $pwdgen->{'pwd'} = word3( $pwdgen->{'len'},
			    $pwdgen->{'len'},
			    'en',
			    $pwdgen->{'num'},
			    $pwdgen->{'cap'}
			  );
  } elsif ( ! defined $pwdgen->{'pwd'} ) {
    $pwdgen->{'pwd'} = chars( $pwdgen->{'len'}, $pwdgen->{'len'} );
  }

  use Digest::SHA1;
  use MIME::Base64;
  my $sha1 = Digest::SHA1->new;
  $sha1->add( $pwdgen->{'pwd'}, $pwdgen->{'salt'} );

  return {
	  clear => $pwdgen->{'pwd'},
	  ssha => '{SSHA}' . encode_base64( $sha1->digest . $pwdgen->{'salt'}, '' )
	 };
}


=head2 cert_info

data taken, generally, from

openssl x509 -in target.crt -text -noout

=cut


sub cert_info {
  my ( $self, $args ) = @_;
  my $arg = {
	     cert => $args->{'cert'},
	    };

  use Crypt::X509;
  my $x509 = Crypt::X509->new( cert => join('', $arg->{cert}) );
  use POSIX qw(strftime);
  return {
	  'Subject' => join(',',@{$x509->Subject}),
	  'Issuer' => join(',',@{$x509->Issuer}),
	  'S/N' => $x509->serial,
	  'Not Before' => strftime ("%a %b %e %H:%M:%S %Y", localtime($x509->not_before)),
	  'Not  After' => strftime ("%a %b %e %H:%M:%S %Y", localtime( $x509->not_after)),
	 };
}



=head2 fnorm

HFH field value normalizator. Input is casted to ARRAY if it is
SCALAR.

=cut


sub fnorm {
  my ( $self, $field ) = @_;
  my $field_arr;
  if ( ref( $field ) ne 'ARRAY' ) {
    push $field_arr, $field;
    return $field_arr;
  } else {
    return $field;
  }
}


######################################################################

1;
